<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>åœ°åœ–æ¸¬è©¦ | MoData</title>
    <link rel="stylesheet" href="/mo_data/css/styles.css" />
    <link rel="stylesheet" href="/mo_data/css/map.css" />
    <style>
        /* ------------------ åŸå§‹ CSS & èª¿æ•´ ------------------ */
        /* ç¸®ç•¥åœ– */
        .thumbnail {
            width: 90%;
            height: auto;
            cursor: pointer;
            transition: transform 0.3s ease;
            display: block;
            margin: 0 auto 20px auto;
        }
        .thumbnail:hover {
            transform: scale(1.05);
        }

        /* éš±è—checkbox */
        .zoomToggle {
            display: none;
        }

        /* æ”¾å¤§è¦–çª— (Lightbox) */
        .lightbox {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.8);
            display: none; justify-content: center; align-items: center;
            cursor: zoom-out; z-index: 9999;
            overflow: hidden; touch-action: none;
        }
        /* checkboxé¸ä¸­æ™‚é¡¯ç¤º */
        .zoomToggle:checked + .lightbox {
            display: flex;
        }

        /* ğŸ“Œ æ–°å¢ï¼šåœ°åœ–äº’å‹•å®¹å™¨ï¼Œä½œç‚ºç¸®æ”¾/æ‹–æ›³çš„ç›®æ¨™ */
        .map-interactive-container {
            position: relative; /* æˆç‚ºç†±å€çš„å®šä½åŸºæº– */
            max-width: 90%;
            max-height: 90%;
            /* è®“å®¹å™¨ä¹Ÿèƒ½æ¥æ”¶æ‹–æ›³ cursor */
            transition: transform 0.2s ease; 
        }

        /* æ”¾å¤§åœ– */
        .lightbox img.zoomedImage {
            width: 100%; height: 100%;
            box-shadow: 0 0 30px rgba(255,255,255,0.6);
            border-radius: 10px;
            cursor: grab;
            user-select: none;
            touch-action: none;
        }
        /* æ‹–æ›³æ™‚ cursor */
        .map-interactive-container.dragging {
            cursor: grabbing;
        }

        /* å…¶ä»–åŸæœ‰æ¨£å¼ (åœ–ä¾‹ã€æ¨™é¡Œç­‰) */
        section h2 { text-align: center; margin-bottom: 8px; }
        .map-tip { text-align: center; font-size: 0.9rem; color: #ddd; margin-bottom: 40px; }
        .legend { margin-top: 20px; display: flex; gap: 20px; justify-content: center; font-size: 1rem; color: #333; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .color-box { width: 24px; height: 24px; border-radius: 4px; display: inline-block; box-shadow: 0 0 5px rgba(0, 0, 0, 0.1); }
        .village { background-color: #FFA500; }
        .cave { background-color: #000000; }
        .sacred { background-color: #3399FF; }
        
        /* ------------------ ğŸ“Œ ç†±å€ CSS ------------------ */
        .map-hotspot {
            position: absolute;
            /* æ¸¬è©¦æ™‚é¡¯ç¤ºï¼Œéƒ¨ç½²æ™‚å¯å°‡ opacity è¨­ç‚º 0 */
            background-color: rgba(255, 0, 0, 0.3); 
            border: 2px solid rgba(255, 255, 255, 0.5); 
            border-radius: 5px;
            cursor: pointer;
            z-index: 10000;
            opacity: 1; 
            transition: background-color 0.2s;
        }
        .map-hotspot:hover {
            background-color: rgba(0, 255, 255, 0.5);
            opacity: 1;
        }
        
        /* ------------------ Modal æ¨£å¼ (æ‚¨çš„çµæ§‹) ------------------ */
        #modalOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 9998; display: none; }
        #modalBox { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; z-index: 9999; max-width: 600px; width: 90%; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); display: none; color: #333; }
        #modalBox .close-btn { position: absolute; top: 10px; right: 20px; font-size: 30px; cursor: pointer; color: #aaa; }
        
        /* ç‚ºäº†å®¹ç´åœ–ç‰‡å’Œæ–‡å­—ï¼Œèª¿æ•´å½ˆçª—å…§å®¹ç‚ºå…©æ¬„ (Flex) */
        .hero-column-details { display: flex; gap: 20px; align-items: flex-start; margin-top: 15px; }
        .hero-image { max-width: 50%; height: auto; object-fit: contain; border-radius: 8px; }
        .hero-name { color: #333; margin-top: 0; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .section-gap { margin-top: 10px; }
    </style>
</head>
<body>
    <div id="nav-container"></div>
    <script src="/mo_data/js/componentsLoader.js"></script>

    <section class="map-section">
        <div class="legend">
            <div class="legend-item"><span class="color-box village"></span><span>æ‘èŠ</span></div>
            <div class="legend-item"><span class="color-box cave"></span><span>æ´çªŸ</span></div>
            <div class="legend-item"><span class="color-box sacred"></span><span>éœ€è¦ç ´é‚ªè­·ç¬¦</span></div>
        </div>
    </section>

    <section class="map-section">
        <h2>ä¸€èˆ¬åœ°åœ–</h2>
        <label for="zoomToggle1">
            <img class="thumbnail" src="/mo_data/pic/map/map.png" alt="éŠæˆ²åœ°åœ–ç¸®ç•¥åœ–" />
        </label>
        <input type="checkbox" id="zoomToggle1" class="zoomToggle" />
        
        <div class="lightbox" data-for="zoomToggle1" onclick="if(event.target.classList.contains('lightbox')) closeLightbox('zoomToggle1')">
            
            <div class="map-interactive-container" data-for="zoomToggle1"> 
                <img class="zoomedImage" src="/mo_data/pic/map/map.png" alt="éŠæˆ²åœ°åœ–æ”¾å¤§åœ–" draggable="false" data-for="zoomToggle1" />
                
                <button class="map-hotspot" 
                        style="left: 9.5%; top: 19.5%; width: 5%; height: 5%;"
                        data-map-id="Aæ‘èŠ" 
                        title="Aæ‘èŠ"></button>
                        
                <button class="map-hotspot" 
                        style="left: 44%; top: 59%; width: 4%; height: 8%;"
                        data-map-id="Bæ´çªŸ"
                        title="Bæ´çªŸ"></button>
                        
                <button class="map-hotspot" 
                        style="left: 70%; top: 30%; width: 8%; height: 6%;"
                        data-map-id="Cå€åŸŸ"
                        title="Cå€åŸŸ"></button>
            </div>
        </div>
        <p class="map-tip">é»æ“Šåœ–ç‰‡å¯æ”¾å¤§ï¼Œæ”¾å¤§å¾Œå¯ç”¨æ»‘é¼ æ»¾è¼ªç¸®æ”¾èˆ‡æ‹–æ›³ï¼Œé»æ“ŠèƒŒæ™¯é—œé–‰ã€‚é»æ“Šåœ°åœ–ä¸Šçš„ç´…è‰²ç†±å€å¯é¡¯ç¤ºåœ°é»è©³æƒ…ã€‚</p>
    </section>

    <section class="map-section">
        <h2>ä»™ç•Œåœ°åœ–</h2>
        <label for="zoomToggle2">
            <img class="thumbnail" src="/mo_data/pic/map/map-1.png" alt="ä»™ç•Œåœ°åœ–ç¸®ç•¥åœ–" />
        </label>
        <input type="checkbox" id="zoomToggle2" class="zoomToggle" />
        <div class="lightbox" data-for="zoomToggle2" onclick="if(event.target.classList.contains('lightbox')) closeLightbox('zoomToggle2')">
            <div class="map-interactive-container" data-for="zoomToggle2">
                <img class="zoomedImage" src="/mo_data/pic/map/map-1.png" alt="ä»™ç•Œåœ°åœ–æ”¾å¤§åœ–" draggable="false" data-for="zoomToggle2" />
            </div>
        </div>
        <p class="map-tip">é»æ“Šåœ–ç‰‡å¯æ”¾å¤§ï¼Œæ”¾å¤§å¾Œå¯ç”¨æ»‘é¼ æ»¾è¼ªç¸®æ”¾èˆ‡æ‹–æ›³ï¼Œé»æ“ŠèƒŒæ™¯é—œé–‰</p>
    </section>
    
    <div id="footer-container"></div>
    
    <div id="modalOverlay"></div>
    <div id="modalBox">
        <span class="close-btn">&times;</span>
        <div id="modalContent">
            </div>
    </div>

    <script>
        // ----------------------------------------------------
        // ğŸ“Œ MODAL / JSON è™•ç†ç›¸é—œè®Šæ•¸ (åœ°åœ–è³‡æ–™)
        // ----------------------------------------------------
        let mapData = []; 

        document.addEventListener("DOMContentLoaded", () => {
            // === è¼‰å…¥ JSON è³‡æ–™ ===
            fetch("/mo_data/data/detailed_maptest.json")
                .then(res => {
                    if (!res.ok) throw new Error("è¼‰å…¥ detailed_map.json å¤±æ•—");
                    return res.json();
                })
                .then(json => {
                    mapData = Array.isArray(json) ? json : json.data; 
                    preloadCardImages(mapData);
                    initMapHotspots(mapData); // ğŸ“Œ ç¶å®šç†±å€äº‹ä»¶
                })
                .catch(err => {
                    console.error("âŒ JSON è¼‰å…¥å¤±æ•—ï¼š", err);
                    alert("åœ°åœ–è©³ç´°è³‡æ–™è¼‰å…¥å¤±æ•—ï¼Œç„¡æ³•å•Ÿç”¨ç†±å€é»æ“ŠåŠŸèƒ½ã€‚è«‹æª¢æŸ¥ detailed_map.jsonã€‚");
                });
            
            // ... (å…¶ä»– DOMContentLoaded äº‹ä»¶ä¿æŒä¸è®Š) ...
            document.addEventListener("click", e => {
                if (e.target.classList.contains("accordion-header")) {
                    e.target.parentElement.classList.toggle("collapsed");
                }
            });
            
            // === é—œé–‰ Modal (è¼‰å…¥å¾Œç¶å®š) ===
            const closeModal = () => {
                document.getElementById("modalOverlay").style.display = "none";
                document.getElementById("modalBox").style.display = "none";
            };
            const closeBtn = document.querySelector("#modalBox .close-btn");
            if (closeBtn) closeBtn.addEventListener("click", closeModal);
            document.getElementById("modalOverlay").addEventListener("click", closeModal);
        });

        // === é è¼‰å¡åœ– (ä½¿ç”¨ mapid è¼‰å…¥åœ–ç‰‡) ===
        function preloadCardImages(data) {
            data.forEach(item => {
                const img = new Image();
                img.src = `/mo_data/pic/map/${encodeURIComponent(item.mapid)}.jpg`;
            });
        }

        // ğŸ“Œ æ ¸å¿ƒå‡½æ•¸ï¼šåˆå§‹åŒ–åœ°åœ–ç†±å€é»æ“Šäº‹ä»¶
        function initMapHotspots(data) {
            document.querySelectorAll('.map-hotspot').forEach(hotspot => {
                hotspot.addEventListener('click', (e) => {
                    // é˜»æ­¢é»æ“Šäº‹ä»¶å‘ä¸Šå‚³æ’­åˆ° lightboxï¼Œé¿å…é—œé–‰
                    e.stopPropagation(); 
                    
                    const mapId = e.target.dataset.mapId;
                    
                    // æ ¹æ“š data-map-id å°‹æ‰¾ JSON ä¸­å°æ‡‰çš„è³‡æ–™
                    const item = data.find(i => i.mapid === mapId); 
                    
                    if (item) {
                        showDetailModal(item);
                    } else {
                        alert(`æ‰¾ä¸åˆ° ID ç‚º "${mapId}" çš„åœ°åœ–è³‡æ–™ã€‚è«‹æª¢æŸ¥ JSON æª”æ¡ˆã€‚`);
                        console.warn(`æ‰¾ä¸åˆ° ID ç‚º ${mapId} çš„åœ°åœ–è³‡æ–™`);
                    }
                });
            });
        }

        // === Modal é¡¯ç¤º (ä½¿ç”¨æ‚¨æä¾›çš„å…§å®¹ï¼Œèª¿æ•´åœ–ç‰‡æ’ç‰ˆ) ===
        async function showDetailModal(item) {
            const overlay = document.getElementById("modalOverlay");
            const modalBox = document.getElementById("modalBox");
            const contentDiv = document.getElementById("modalContent");

            const img = new Image();
            img.alt = item.mapid;
            img.className = "hero-image";
            img.style.width = "auto";
            img.style.height = "auto";
            img.style.objectFit = "contain";

            const path = `/mo_data/pic/map/${item.mapid}.jpg`;

            try {
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = path;
                });
            } catch {
                console.warn(`åœ–ç‰‡è¼‰å…¥å¤±æ•— (${path})ï¼Œä½¿ç”¨é è¨­åœ–`);
                img.src = "/mo_data/pic/default.png";
            }

            // ğŸ“Œ æ ¸å¿ƒ HTML å…§å®¹ï¼šå°‡åœ–ç‰‡å’Œæ–‡å­—åˆ†å…©æ¬„é¡¯ç¤º
            const html = `
                <h2 class="hero-name">${item.mapid}</h2>
                <div class="hero-column-details">
                    <div style="flex:1;"></div> 
                    
                    <div style="flex:1;">
                         <p><strong>ç­‰ç´šï¼š</strong>${item.maplv}</p>
                         <p><strong>åƒåœ¾æ‰è½ï¼š</strong>${item.drop_rubbish}</p>
                         <p class="section-gap"><strong>å…‰è¼æ‰è½(æ‰è½è¼ƒå¤š)ï¼š</strong><span>${item.drop_glory_high}</span></p>
                         <p class="section-gap"><strong>å…‰è¼æ‰è½(æ‰è½è¼ƒä½)ï¼š</strong><span>${item.drop_glory_low}</span></p>
                         <p class="section-gap"><strong>å…‰è¼æ‰è½(ç©å®¶æä¾›)ï¼š</strong>-</p>
                    </div>
                </div>
            `;
            
            contentDiv.innerHTML = html;
            
            // å°‡è¼‰å…¥çš„åœ–ç‰‡æ’å…¥åˆ°å·¦å´å®¹å™¨ä¸­
            const imgContainer = contentDiv.querySelector(".hero-column-details > div:first-child");
            if(imgContainer) {
                 imgContainer.appendChild(img);
            }

            overlay.style.display = "block";
            modalBox.style.display = "block";
        }
        
        // ----------------------------------------------------
        // ğŸ“Œ åŸå§‹åœ°åœ–æ‹–æ›³/ç¸®æ”¾é‚è¼¯ (å·²ä¿®æ”¹ç‚ºå° .map-interactive-container é€²è¡Œæ“ä½œ)
        // ----------------------------------------------------
        const imagesState = {};

        document.querySelectorAll('.zoomToggle').forEach(checkbox => {
            const id = checkbox.id;
            imagesState[id] = { scale: 1, translateX: 0, translateY: 0, isDragging: false, startX: 0, startY: 0, lastTouchDistance: null, lastTouchCenter: null };
            checkbox.addEventListener('change', e => {
                if (e.target.checked) resetTransform(id);
            });
        });

        function getInteractiveContainer(id) {
            return document.querySelector(`.map-interactive-container[data-for="${id}"]`);
        }
        
        function resetTransform(id) {
            const state = imagesState[id];
            state.scale = 1; state.translateX = 0; state.translateY = 0; 
            state.lastTouchDistance = null; state.lastTouchCenter = null;
            updateTransform(id);
        }

        function updateTransform(id) {
            const state = imagesState[id];
            const container = getInteractiveContainer(id);
            container.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
        }

        function closeLightbox(id) {
            document.getElementById(id).checked = false;
            resetTransform(id);
        }

        function getDistance(touches) {
            const [touch1, touch2] = touches;
            return Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        }

        function getCenter(touches) {
            const [touch1, touch2] = touches;
            return { x: (touch1.clientX + touch2.clientX) / 2, y: (touch1.clientY + touch2.clientY) / 2 };
        }

        document.querySelectorAll('.map-interactive-container').forEach(container => {
            const id = container.dataset.for;
            const state = imagesState[id];

            // æ»¾è¼ªç¸®æ”¾ (ç¶å®šåœ¨ lightbox ä¸Š)
            container.parentElement.addEventListener('wheel', e => {
                e.preventDefault();
                const scaleAmount = e.deltaY < 0 ? 1.1 : 0.9;
                const prevScale = state.scale;
                state.scale *= scaleAmount;
                state.scale = Math.min(5, Math.max(0.5, state.scale));

                const rect = container.getBoundingClientRect();
                const offsetX = e.clientX - rect.left;
                const offsetY = e.clientY - rect.top;

                state.translateX -= (offsetX / prevScale - offsetX / state.scale) * prevScale; 
                state.translateY -= (offsetY / prevScale - offsetY / state.scale) * prevScale; 

                updateTransform(id);
            });

            // æ»‘é¼ æ‹–æ›³é–‹å§‹
            container.addEventListener('mousedown', e => {
                e.preventDefault();
                if (state.scale > 1) { 
                    state.isDragging = true;
                    state.startX = e.clientX - state.translateX;
                    state.startY = e.clientY - state.translateY;
                    container.classList.add('dragging'); 
                }
            });

            // æ»‘é¼ æ‹–æ›³ä¸­ (ç¶å®šåœ¨ window ä¸Š)
            window.addEventListener('mousemove', e => {
                if (!state.isDragging) return;
                state.translateX = e.clientX - state.startX;
                state.translateY = e.clientY - state.startY;
                updateTransform(id);
            });

            // æ»‘é¼ æ‹–æ›³çµæŸ (ç¶å®šåœ¨ window ä¸Š)
            window.addEventListener('mouseup', e => {
                if (state.isDragging) {
                    state.isDragging = false;
                    container.classList.remove('dragging');
                }
            });

            // è§¸æ§é–‹å§‹
            container.addEventListener('touchstart', e => {
                if (document.getElementById(id).checked) e.preventDefault();
                
                if (e.touches.length === 1) {
                    if (state.scale > 1) { 
                        state.isDragging = true;
                        const touch = e.touches[0];
                        state.startX = touch.clientX - state.translateX;
                        state.startY = touch.clientY - state.translateY;
                        container.classList.add('dragging');
                    }
                } else if (e.touches.length === 2) {
                    state.isDragging = false;
                    state.lastTouchDistance = getDistance(e.touches);
                    state.lastTouchCenter = getCenter(e.touches);
                }
            }, { passive: false });

            // è§¸æ§ç§»å‹•
            container.addEventListener('touchmove', e => {
                if (document.getElementById(id).checked) e.preventDefault();
                
                if (e.touches.length === 1 && state.isDragging) {
                    const touch = e.touches[0];
                    state.translateX = touch.clientX - state.startX;
                    state.translateY = touch.clientY - state.startY;
                    updateTransform(id);
                } else if (e.touches.length === 2) {
                    const newDistance = getDistance(e.touches);
                    const newCenter = getCenter(e.touches);

                    if (state.lastTouchDistance) {
                        const scaleChange = newDistance / state.lastTouchDistance;
                        const prevScale = state.scale;
                        state.scale *= scaleChange;
                        state.scale = Math.min(5, Math.max(0.5, state.scale));

                        const rect = container.getBoundingClientRect();
                        const offsetX = state.lastTouchCenter.x - rect.left;
                        const offsetY = state.lastTouchCenter.y - rect.top;

                        state.translateX -= (offsetX / prevScale - offsetX / state.scale) * prevScale; 
                        state.translateY -= (offsetY / prevScale - offsetY / state.scale) * prevScale; 

                        const dx = newCenter.x - state.lastTouchCenter.x;
                        const dy = newCenter.y - state.lastTouchCenter.y;
                        state.translateX += dx;
                        state.translateY += dy;

                        updateTransform(id);
                    }

                    state.lastTouchDistance = newDistance;
                    state.lastTouchCenter = newCenter;
                }
            }, { passive: false });

            // è§¸æ§çµæŸ
            container.addEventListener('touchend', e => {
                 if (e.touches.length === 0) {
                    state.isDragging = false;
                    state.lastTouchDistance = null;
                    state.lastTouchCenter = null;
                    container.classList.remove('dragging');
                } else if (e.touches.length === 1 && state.scale > 1) {
                    const touch = e.touches[0];
                    state.isDragging = true;
                    state.startX = touch.clientX - state.translateX;
                    state.startY = touch.clientY - state.translateY;
                    container.classList.add('dragging');
                    state.lastTouchDistance = null;
                    state.lastTouchCenter = null;
                }
            }, { passive: false });
        });
    </script>
</body>
</html>